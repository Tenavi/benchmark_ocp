from scipy.interpolate import BarycentricInterpolator, interp1d

from optimalcontrol.utilities import saturate
from optimalcontrol.open_loop.solutions import OpenLoopSolution
from .radau import time_map, inverse_time_map
from .utilities import separate_vars


class DirectSolution(OpenLoopSolution):
    def __init__(self, t, x, u, p, v, status, message, tau=None,
                 u_lb=None, u_ub=None):
        self._u_lb, self._u_ub = u_lb, u_ub

        if tau is None:
            tau = time_map(t)

        self._x_interp = BarycentricInterpolator(tau, x, axis=-1)
        self._u_interp = BarycentricInterpolator(tau, u, axis=-1)
        self._p_interp = BarycentricInterpolator(tau, p, axis=-1)
        self._v_interp = interp1d(t, v)

        super().__init__(t, x, u, p, v, status, message)

    def __call__(self, t):
        tau = time_map(t)

        x = self._x_interp(tau)
        u = self._u_interp(tau)
        u = saturate(u, self._u_lb, self._u_ub)
        p = self._p_interp(tau)

        v = self._v_interp(t)

        return x, u, p, v

    @classmethod
    def from_minimize_result(cls, minimize_result, ocp, tau, w, order):
        """
        Instantiate a `DirectSolution` from the result of calling
        `scipy.optimize.minimize` on a nonlinear programming problem set up with
        `.solve.solve_infinite_horizon`

        Parameters
        ----------
        minimize_result : `OptimizeResult`
            Solution of the nonlinear programming problem generated by
            pseudospectral collocation of `ocp`, as returned by
            `scipy.optimize.minimize`.
        ocp : `OptimalControlProblem`
            The optimal control problem which was solved.
        tau : (n_nodes,) array
            LGR collocation nodes on [-1, 1). See `.radau.make_lgr`.
        w : (n_nodes,) array
            LGR quadrature weights corresponding to the collocation points
            `tau`.  See `.radau.make_lgr`.
        order : {'C', 'F'}
            If the problem was set up with C ('C', row-major) or Fortran
            ('F', column-major) ordering.

        Returns
        -------
        ocp_sol : `DirectSolution`
            The open-loop solution to `ocp` extracted from `minimize_result`.
        """
        t = inverse_time_map(tau)
        x, u = separate_vars(minimize_result.x, ocp.n_states, ocp.n_controls,
                             order=order)

        # Extract KKT multipliers and use to approximate costates
        p = minimize_result.kkt['eq'][0].reshape(x.shape, order=order)
        p = p / w.reshape(1, -1)

        v = ocp.total_cost(t, x, u)[::-1]

        return cls(t, x, u, p, v, minimize_result.status,
                   minimize_result.message, tau=tau,
                   u_lb=getattr(ocp.parameters, 'u_lb', None),
                   u_ub=getattr(ocp.parameters, 'u_ub', None))
